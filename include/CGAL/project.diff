diff --git a/examples/Spatial_searching/nearest_neighbor_searching.cpp b/examples/Spatial_searching/nearest_neighbor_searching.cpp
index 8055c8b..89c9141 100644
--- a/examples/Spatial_searching/nearest_neighbor_searching.cpp
+++ b/examples/Spatial_searching/nearest_neighbor_searching.cpp
@@ -1,37 +1,91 @@
 #include <CGAL/Simple_cartesian.h>
 #include <CGAL/point_generators_2.h>
 #include <CGAL/Orthogonal_k_neighbor_search.h>
-#include <CGAL/Search_traits_2.h>
+#include <CGAL/Search_traits_3.h>
+#include <CGAL/Projection_traits_xy_3.h>
+#include <CGAL/Projection_traits_xz_3.h>
+#include <CGAL/Projection_traits_yz_3.h>
 #include <list>
+#include <vector>
 #include <cmath>
 
-
 typedef CGAL::Simple_cartesian<double> K;
-typedef K::Point_2 Point_d;
-typedef CGAL::Search_traits_2<K> TreeTraits;
-typedef CGAL::Orthogonal_k_neighbor_search<TreeTraits> Neighbor_search;
-typedef Neighbor_search::Tree Tree;
+typedef K::Point_3 Point_d;
+typedef CGAL::Projection_traits_xy_3<K> TreeTraitsXY;
+typedef CGAL::Projection_traits_xz_3<K> TreeTraitsXZ;
+typedef CGAL::Projection_traits_yz_3<K> TreeTraitsYZ;
 
-int main() {
-  const unsigned int N = 1;
+template<class ProjectionTraits>
+bool same_projection(const std::list<Point_d> &l1, const std::list<Point_d>& l2) {
+  ProjectionTraits pt;
+  if(l1.size() != l2.size())
+    return false;
+  std::list<Point_d>::const_iterator it1;
+  std::list<Point_d>::const_iterator it2;
+  for(it1 = l1.begin(), it2 = l2.begin(); it1 != l1.end(); it1++, it2++)
+    if(pt.x(*it1) != pt.x(*it2) || pt.y(*it1) != pt.y(*it2)) 
+      return false;
+  return true;
+} 
+
+template<class ProjectionTraits>
+void getPointList(CGAL::Orthogonal_k_neighbor_search<ProjectionTraits> ns, std::list<Point_d> &l) {
+  l.clear();
+  typename CGAL::Orthogonal_k_neighbor_search<ProjectionTraits>::iterator it;
+  for(it = ns.begin(); it != ns.end(); it++)
+    l.push_back(it->first);
+} 
 
-  std::list<Point_d> points;
-  points.push_back(Point_d(0,0));
+void create_points(std::list<Point_d>& ret, int fill_value, int x_idx, int y_idx, int size) {
+  int i = 0;
+  std::vector<std::vector<double> > m(size, std::vector<double>(3));
+  for(std::vector<std::vector<double> >::iterator it = m.begin(); it != m.end(); it++, i++) {
+    (*it)[0] = (*it)[1] = (*it)[2] = fill_value;
+    (*it)[x_idx] = i;
+    (*it)[y_idx] = i;
+  } 
+  for(std::vector<std::vector<double> >::iterator it = m.begin(); it != m.end(); it++) 
+    ret.push_back(Point_d((*it)[0], (*it)[1], (*it)[2])); 
+}  
 
-  Tree tree(points.begin(), points.end());
 
-  Point_d query(0,0);
+template<class ProjectionTraits>
+void test(unsigned int n, int x_idx, int y_idx, bool print_points = false) {
+  const int size = 10;
+  std::list<Point_d> p1, p2, ref;
+  create_points(p1, 1, x_idx, y_idx, size);
+  create_points(p2, 2, x_idx, y_idx, size);
+  create_points(ref, 0, x_idx, y_idx, n);
 
-  // Initialize the search structure, and search all N points
+  typename CGAL::Orthogonal_k_neighbor_search<ProjectionTraits>::Tree 
+      t1(p1.begin(), p1.end()), t2(p2.begin(), p2.end());
+  Point_d query(0, 0, 0);
+  CGAL::Orthogonal_k_neighbor_search<ProjectionTraits> 
+      ns1(t1, query, n), ns2(t2, query, n);
 
-  Neighbor_search search(tree, query, N);
+  getPointList(ns1, p1);
+  getPointList(ns2, p2);
 
-   // report the N nearest neighbors and their distance
-  // This should sort all N points by increasing distance from origin
-  for(Neighbor_search::iterator it = search.begin(); it != search.end(); ++it){
-    std::cout << it->first << " "<< std::sqrt(it->second) << std::endl;
-  }
+  assert(same_projection<ProjectionTraits>(p1, p2));
+  assert(same_projection<ProjectionTraits>(ref, p2));
 
+  if(print_points) {
+    std::cout << "Points from first list\n";
+    for(std::list<Point_d>::iterator it = p1.begin(); it != p1.end(); it++)
+      std::cout << *it << '\n';
+    std::cout << "Points from second list\n";
+    for(std::list<Point_d>::iterator it = p2.begin(); it != p2.end(); it++)
+      std::cout << *it << '\n';
+  } 
+} 
 
+int main() {
+  std::cout << "Test Projection_traits_xy_3\n";
+  test<TreeTraitsXY>(3, 0, 1, true);
+  std::cout << "\nTest Projection_traits_xz_3\n";
+  test<TreeTraitsXZ>(3, 0, 2, true);
+  std::cout << "\nTest Projection_traits_yz_3\n";
+  test<TreeTraitsYZ>(3, 1, 2, true);
   return 0;
 }
+
diff --git a/include/CGAL/Projection_traits_xy_3.h b/include/CGAL/Projection_traits_xy_3.h
index b173788..ee0b8d7 100644
--- a/include/CGAL/Projection_traits_xy_3.h
+++ b/include/CGAL/Projection_traits_xy_3.h
@@ -22,13 +22,24 @@
 #define CGAL_PROJECTION_TRAITS_XY_3_H
 
 #include <CGAL/internal/Projection_traits_3.h>
-
 namespace CGAL { 
 
 template < class R >
 class Projection_traits_xy_3
   : public internal::Projection_traits_3<R,2>
-{};
+{
+ public:
+    typedef typename internal::Cartesian_const_projection_iterator<R, 2> Cartesian_const_iterator_d;
+    typedef typename R::Point_3 Point_d;
+    typedef internal::Construct_cartesian_const_projection_iterator<R, 2> Construct_cartesian_const_iterator_d;
+    typedef typename R::FT FT;
+    typename R::FT x(const Point_d& p) { return internal::Projection_traits_3<R, 2>::x(p); } 
+    typename R::FT y(const Point_d& p) { return internal::Projection_traits_3<R, 2>::y(p); } 
+  
+    Construct_cartesian_const_iterator_d construct_cartesian_const_iterator_d_object() const {
+       return Construct_cartesian_const_iterator_d();
+    }  
+};
   
 } //namespace CGAL 
 
diff --git a/include/CGAL/Projection_traits_xz_3.h b/include/CGAL/Projection_traits_xz_3.h
index f094e79..90120b7 100644
--- a/include/CGAL/Projection_traits_xz_3.h
+++ b/include/CGAL/Projection_traits_xz_3.h
@@ -28,7 +28,19 @@ namespace CGAL {
 template < class R >
 class Projection_traits_xz_3
   : public internal::Projection_traits_3<R,1>
-{};
+{
+  public:
+    typedef typename internal::Cartesian_const_projection_iterator<R, 1> Cartesian_const_iterator_d;
+    typedef typename R::Point_3 Point_d;
+    typedef internal::Construct_cartesian_const_projection_iterator<R, 1> Construct_cartesian_const_iterator_d;
+    typedef typename R::FT FT;
+    typename R::FT x(const Point_d& p) { return internal::Projection_traits_3<R, 1>::x(p); }
+    typename R::FT y(const Point_d& p) { return internal::Projection_traits_3<R, 1>::y(p); }  
+  
+    Construct_cartesian_const_iterator_d construct_cartesian_const_iterator_d_object() const {
+       return Construct_cartesian_const_iterator_d();
+    }  
+};
 
 } //namespace CGAL
 
diff --git a/include/CGAL/Projection_traits_yz_3.h b/include/CGAL/Projection_traits_yz_3.h
index 6ed6728..e5c453c 100644
--- a/include/CGAL/Projection_traits_yz_3.h
+++ b/include/CGAL/Projection_traits_yz_3.h
@@ -28,7 +28,19 @@ namespace CGAL {
 template < class R >
 class Projection_traits_yz_3
   : public internal::Projection_traits_3<R,0>
-{};
+{
+
+  public:
+    typedef typename internal::Cartesian_const_projection_iterator<R, 0> Cartesian_const_iterator_d;
+    typedef typename R::Point_3 Point_d;
+    typedef internal::Construct_cartesian_const_projection_iterator<R, 0> Construct_cartesian_const_iterator_d;
+    typedef typename R::FT FT;
+    typename R::FT x(const Point_d& p) { return internal::Projection_traits_3<R, 0>::x(p); }   
+    typename R::FT y(const Point_d& p) { return internal::Projection_traits_3<R, 0>::y(p); }   
+    Construct_cartesian_const_iterator_d construct_cartesian_const_iterator_d_object() const {
+       return Construct_cartesian_const_iterator_d();
+    }  
+};
 
 } //namespace CGAL
 
diff --git a/include/CGAL/internal/Projection_traits_3.h b/include/CGAL/internal/Projection_traits_3.h
index 54aec35..7bf52c1 100644
--- a/include/CGAL/internal/Projection_traits_3.h
+++ b/include/CGAL/internal/Projection_traits_3.h
@@ -29,13 +29,18 @@
 
 #include <CGAL/Kernel/global_functions_2.h>
 
+#include <iterator>
 namespace CGAL { 
 
 namespace internal {
 
 //project Point_3 along coordinate dim
 template <class R,int dim>
-struct Projector;
+struct Projector{
+  static const int x_index = -1;
+  static const int y_index = -1;
+};
+
 
 //project onto yz
 template <class R>
@@ -53,6 +58,7 @@ struct Projector<R,0>
   static const int x_index=1;
   static const int y_index=2;
 };
+
 //project onto xz
 template <class R>
 struct Projector<R,1>
@@ -85,7 +91,118 @@ struct Projector<R,2>
   static const int y_index=1;  
 };
   
+template < typename R , int dim >
+class Cartesian_const_projection_iterator
+{
+  typedef typename R::Cartesian_const_iterator_3      iterator_type;
+  typedef Cartesian_const_projection_iterator self;
+  int offset;
+  
+public:
+  typedef std::random_access_iterator_tag         iterator_category;
+  typedef typename R::FT                  value_type;
+  typedef std::ptrdiff_t                  difference_type;
+  typedef const value_type*               pointer;
+  typedef const value_type&               reference;
+
+  Cartesian_const_projection_iterator() {}
+  Cartesian_const_projection_iterator(iterator_type it, int offset)
+    : _it(it), offset(offset) {}
+
+  self& operator++() { 
+    ++_it; ++offset;
+    return *this; 
+  }
+
+  self  operator++(int) {
+    self tmp = *this; 
+    ++_it; ++offset;
+    return tmp;
+  }
+
+  self& operator--() {
+    --_it; --offset;
+    return *this; 
+  }
+
+  self  operator--(int) {
+    self tmp = *this;
+    --_it; --offset;
+    return tmp;
+  }
+
+  self& operator+=(difference_type i) {
+    _it+=i; offset += i; 
+    return *this; 
+  }
+
+  self& operator-=(difference_type i) { 
+    _it-=i; offset -= i; 
+    return *this; 
+  }
+
+  self operator+(difference_type i) const
+  { self tmp=*this; return tmp += i; }
+  self operator-(difference_type i) const
+  { self tmp=*this; return tmp -= i; }
+
+  difference_type operator-(self x) const { return _it-x._it; }
+
+  value_type operator*() const { 
+      if(offset != Projector<R, dim>::x_index && offset != Projector<R, dim>::y_index)
+        return value_type(0);
+      return value_type(*_it); 
+  }
 
+  value_type operator[](difference_type i) const { 
+    if(i != Projector<R, dim>::x_index && i != Projector<R, dim>::y_index)
+      return value_type(0);
+    return *(*this + i);  
+  }
+
+  bool operator==(const self& x) const { return _it==x._it ; }
+  bool operator!=(const self& x) const { return ! (*this==x); }
+  bool operator<(const self& x) const { return (x - *this) > 0; }
+
+private:
+   iterator_type _it;
+};
+
+
+template <typename K, int dim>
+class Construct_cartesian_const_projection_iterator
+{
+  typedef typename K::Point_3          Point_3;
+  typedef typename K::Vector_3         Vector_3;
+  typedef typename internal::Cartesian_const_projection_iterator<K, dim> Cartesian_const_iterator_3;
+
+  public:
+    typedef Cartesian_const_iterator_3 result_type;
+
+    Cartesian_const_iterator_3
+    operator()( const Point_3& p) const
+    {
+      return Cartesian_const_iterator_3(p.rep().cartesian_begin(), 0);
+    }
+
+    Cartesian_const_iterator_3
+    operator()( const Point_3& p, int) const
+    {
+      return Cartesian_const_iterator_3(p.rep().cartesian_end(), 3); 
+    }
+
+    Cartesian_const_iterator_3
+    operator()( const Vector_3& v) const
+    {
+      return Cartesian_const_iterator_3(v.rep().cartesian_begin(), 0);
+    }
+
+    Cartesian_const_iterator_3
+    operator()( const Vector_3& v, int) const
+    {
+     return Cartesian_const_iterator_3(v.rep().cartesian_end(), 3); 
+    }
+};
 
 template <class R,int dim>
 class Orientation_projected_3 
